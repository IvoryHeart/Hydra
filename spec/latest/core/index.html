<!DOCTYPE html>
<html>
<head>
<title>Hydra Core Vocabulary</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script type="text/javascript" src="../../../js/respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" src="../../../js/jsonld.js" class="remove"></script>
<script type="text/javascript" src="../../../js/respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      "localBiblio": localBibliography,

      doRDFa: "1.1",
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "unofficial",
      // if you wish the publication date to be other than today, set this
      //publishDate:          "2012-08-30",
      copyrightStart:       "2012",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "hydra-core",
      subtitle:             "A Vocabulary for Hypermedia-Driven Web APIs",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "2012-08-30",
      // previousMaturity:     "FPWD",
      // previousDiffURI:      "http://www.w3.org/TR/2012/WD-json-ld-syntax-20120830/",
      // diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://www.markus-lanthaler.com/hydra/spec/latest/core/index.html",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      issueBase: "https://github.com/lanthaler/hydra/issues/",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS:             [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
      ],

      // name of the WG
      // wg:           "RDF Working Group",

      // URI of the public WG page
      // wgURI:        "http://www.w3.org/2011/rdf-wg/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      // wgPublicList: "public-rdf-comments",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/46168/status",
      maxTocLevel: 4,
      preProcess: [ preProc ]
      //alternateFormats: [ {uri: "diff-20120712.html", label: "diff to previous version"} ]
  };
//]]>
</script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-36111533-1']);
  _gaq.push(['_setDomainName', 'markus-lanthaler.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<style type="text/css">
  .hlist {
    border: 1px solid navy;
    padding:5px;
    background-color: #F4FFFF;
  }

  .hlist li {
    display: inline;
    display: inline-table;
    list-style-type: none;
    padding-right: 20px;
  }
  .highlight {
    font-weight: bold;
    color: #0a3;
  }
  .illustration {
    text-align: center;
  }
  #vocabulary-jsonld {
    white-space: pre-wrap;
  }
</style>
</head>

<body>
<section id="abstract">
  <p>Hydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it renders
    the creation of generic API clients possible.</p>
</section>

<section id="sotd">
  <p>To participate in the development of this specification please file bugs
    and issues in the <a href="https://github.com/lanthaler/Hydra/issues">issue tracker</a>.</p>
</section>

<section class="informative">
  <h2>Introduction</h2>

  <p>Coping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.</p>

  <p>The combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.</p>
</section>

<section>
  <h2>Conformance</h2>

  <p>This specification describes the conformance criteria for
    <dfn title="Hydra API description">Hydra API descriptions</dfn> and
    <dfn title="Hydra client">Hydra clients</dfn>. This criteria is
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.</p>

  <p>The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].</p>
</section>

<section class="informative">
  <h2>Hydra at a Glance</h2>

  <p>The basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.</p>

  <p>The figure below illustrates the Hydra core vocabulary (the figure’s
    intention is to show how Hydra is used rather than its precise
    definition).</p>

  <p class="issue">Is this illustration clear enough or is it confusing?
    Feedback would be much appreciated.</p>

  <div class="illustration">
    <p><img src="vocabulary.png" alt="The Hydra core vocabulary" /></p>
    <p class="caption">The Hydra core vocabulary</p>
  </div>

  <p>An alphabetical index of the classes and properties of Hydra are
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.</p>

  <p id="vocabulary-overview"></p>

  <p class="issue">The used prefixes should be documented somewhere.</p>
</section>

<section>
  <h2>Using Hydra</h2>

  <p>Throughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    users to file new issues and to modify or comment existing ones.</p>

  <section>
    <h3>Documenting a Web API</h3>
  </section>

  <section>
    <h3>Accessing a Hydra-powered Web API</h3>

    <p>The first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look a Link Header with a relation type
      <code>http://purl.org/hydra/core#apiDocumentation</code> (this is
      the IRI identifying the <i>hydra:apiDocumentation</i> property).</p>

    <p>In the following example, a Hydra client simply accesses the
      homepage of an API publisher, <code>http://www.example.com</code>
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.</p>

    <pre class="example" data-transform="updateExample"
         title="Discovering Hydra API documentation documents">
      <!--
      HEAD / HTTP/1.1
      Host: www.example.com

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: application/ld+json
      ****Link: <http://api.example.com/doc/>;
            rel="http://purl.org/hydra/core#apiDocumentation"****
      -->
    </pre>

    <p>The response in the example above contains an HTTP Link Header
      pointing to <code>http://api.example.com/doc/api.jsonld</code>.
      Retrieving that resource, the client would obtain a
      <a>Hydra API description</a> that documents the API's main entry
      point:</p>

    <pre class="example" data-transform="updateExample"
         title="Retrieving a Hydra API description to obtain the main entry point">
      <!--
      GET /doc/ HTTP/1.1
      Host: api.example.com
      Accept: application/ld+json,application/json,*/*;q=0.1

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: application/ld+json

      {
        "@context": "context.jsonld",
        "@id": "http://api.example.com/api/doc/",
        "title": "The example.com API",
        ****"entrypoint": "http://api.example.com/"****,
        ...
      }
      -->
    </pre>

    <p>Please note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.</p>
  </section>

  <section>
    <h3>Using Hydra Descriptions as JSON</h3>

    <p class="issue">The are multiple ways to serialize a
      <a>Hydra API description</a> in JSON-LD. To make it usable also for
      plain-old JSON clients, the serialization has to have a deterministic
      shape. The definition of a profile will make it possible to signal
      or request specific serialization conventions at the media type
      level. The definition of the profile might be as simple as defining
      a JSON-LD frame.</p>
  </section>

</section>

<section>
  <h2>Classes</h2>
  <div id="vocabulary-classes"></div>
</section>

<section>
  <h2>Properties</h2>
  <div id="vocabulary-properties"></div>
</section>

<section>
  <h2>External Vocabulary References</h2>

  <p class="issue">Should we reuse things such as HTTP in RDF or should we
    redefine it and just declare it as equivalent?</p>
</section>

<section class="appendix">
  <h2>The Hydra Core Vocabulary in JSON-LD</h2>
  <pre id="vocabulary-jsonld">
  </pre>
</section>

</body>
</html>
